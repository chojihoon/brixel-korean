#include <Wire.h>
#include "English8x16.h"
#include "hmgothic.h"
//#define OLED_height32
//#define OLED_13inch
#define OLED_address 0x3c
#define FONT_SIZE 8
#define INVERSE 0
#define NORMAL 1
#define OLED_WIDTH    128
#define OLED_HEIGHT   64
#define OLED_width    OLED_WIDTH / FONT_SIZE
#define OLED_height   OLED_HEIGHT / FONT_SIZE
#define NORMAL_display 0xa6
#define INVERT_display 0xa7
#define DISPLAY_ON     0xaf
#define DISPLAY_OFF    0xae
#define UP_TO_DOWN     0xc8
#define DOWN_TO_UP     0xc0
#define START_LINE     0x40
#define LEFT_HORIZON    0x27
#define RIGHT_HORIZON   0x26
#define VERTICAL_LEFT   0x2A
#define VERTICAL_RIGHT  0x29
#define SCROLL_ACTIVE   0x2F
#define SCROLL_DEACTIVE 0x2E
#define FRAME5          0
#define FRAME64         1
#define FRAME128        2
#define FRAME256        3
#define FRAME3          4
#define FRAME4          5
#define FRAME25         6
#define FRAME2          7
#define WHITE           1
#define BLACK           0

// SH1106 initialization sequence (removed memory addressing mode command)
const uint8_t sh1106_init_sequence [] PROGMEM = {  // Initialization Sequence
  0xAE,     // Display OFF (sleep mode)
  // Note: SH1106 only supports page addressing mode, so no 0x20 command
  0xB0,     // Set Page Start Address for Page Addressing Mode, 0-7
  0xC8,     // Set COM Output Scan Direction
  0x00,     // ---set low column address
  0x10,     // ---set high column address
  0x40,     // --set start line address
  0x81, 0x3F,   // Set contrast control register
  0xA1,     // Set Segment Re-map. A0=address mapped; A1=address 127 mapped. 
  0xA6,     // Set display mode. A6=Normal; A7=Inverse
  #ifdef OLED_height32
    0xA8, 0x1F,   // Set multiplex ratio(1 to 32)
  #else
    0xA8, 0x3F,   // Set multiplex ratio(1 to 64)
  #endif
  0xA4,     // Output RAM to Display
          // 0xA4=Output follows RAM content; 0xA5,Output ignores RAM content
  0xD3, 0x00,   // Set display offset. 00 = no offset
  0xD5,     // --set display clock divide ratio/oscillator frequency
  0xF0,     // --set divide ratio
  0xD9, 0x22,   // Set pre-charge period
  #ifdef OLED_height32  
    0xDA, 0x02,   // Set com pins hardware configuration   
  #else 
    0xDA, 0x12,   // Set com pins hardware configuration 
  #endif
  0xDB,     // --set vcomh
  0x20,     // 0x20,0.77xVcc
  0x8D, 0x14,   // Set DC-DC enable
  0xAF      // Display ON in normal mode  
};

const byte Seg0[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0x3f,
  0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x1f,0x3f,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0xfc,0xfe,0xff,0xfe,
  0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xfc,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x01,0x0b,0x1d,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};

const byte Seg1[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xf0,0xf8,0xfc,0xf8,0xf0,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x1f,0x3f,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xfc,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x07,0x0f,0x1f,0x0f,0x07,0x00,0x00,0x00,
//
};

const byte Seg2[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
  0xc0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xdf,0xbf,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0xfc,0xfe,0xff,0xfe,
  0xfd,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x01,0x0b,0x1d,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1c,0x08,0x00,0x00,0x00,0x00,0x00,
//
};
const byte Seg3[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
  0xc0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xdf,0xbf,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};
const byte Seg4[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0xe0,0xf0,0xf8,0xf0,
  0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xe0,0xf0,0xf8,0xf0,0xe0,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0xbf,
  0xdf,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xdf,0xbf,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x03,0x07,0x0f,0x07,0x03,0x00,0x00,0x00,
//
};
const byte Seg5[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1c,0x08,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0xbf,
  0xdf,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xc0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};
const byte Seg6[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1c,0x08,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0xbf,
  0xdf,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xc0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0xfc,0xfe,0xff,0xfe,
  0xfd,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x01,0x0b,0x1d,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};
const byte Seg7[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0x3f,
  0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x1f,0x3f,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xfc,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x03,0x07,0x0f,0x07,0x03,0x00,0x00,0x00,
//
};
const byte Seg8[] PROGMEM = { 

  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0xbf,
  0xdf,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xdf,0xbf,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0xfc,0xfe,0xff,0xfe,
  0xfd,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x01,0x0b,0x1d,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};
const byte Seg9[] PROGMEM = { 
  0x00,0x00,0x00,0x00,0x80,0xc0,0xe8,0xdc,
  0xbe,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0xbe,0xdc,0xe8,0xc0,0x80,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x1f,0x3f,0x7f,0xbf,
  0xdf,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,
  0xdf,0xbf,0x7f,0x3f,0x1f,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x1c,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x09,0x01,0x00,0x00,0x00,0x00,
//
};
const byte Seg10[] PROGMEM = { 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0xfc,0xfe,0xff,0xfe,
  0xfd,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0xfd,0xfe,0xff,0xfe,0xfc,0x00,0x00,0x00,
//
  0x00,0x00,0x00,0x00,0x00,0x01,0x0b,0x1d,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x1d,0x0b,0x01,0x00,0x00,0x00,0x00,
//
};

class OLED_uno_lib {  
  public:   
  void command_write( uint8_t command ) {
    Wire.beginTransmission( OLED_address );     //begin transmitting
    Wire.write( 0x00 );                         //command mode
    Wire.write( command );
    Wire.endTransmission();                     // stop transmitting
  }
  void data_write( uint8_t data ) {
    Wire.beginTransmission( OLED_address ); // begin transmitting
    Wire.write( 0x40 );                     //data mode
    Wire.write( data );
    Wire.endTransmission();                 // stop transmitting
  }  
  void init() {    
    Wire.begin();
    Wire.setClock( 400000L );  // 400000L
    Wire.beginTransmission( OLED_address );
    // Use SH1106 initialization sequence
    for (uint8_t i = 0; i < sizeof ( sh1106_init_sequence ); i++) command_write( pgm_read_byte( &sh1106_init_sequence[i] ) );
  }  
  void clearDisplay() {
    int16_t i, j;
    for(i=0;i< ( OLED_HEIGHT / FONT_SIZE ) ; i++ ) {
      gotoXY( 0, i );
      for( j = 0; j < OLED_WIDTH; j++)    data_write( 0 );
    }
  }
  // Modified gotoXY function for SH1106 with 2-pixel column offset
  void gotoXY( int16_t x, int16_t y ) {  
    command_write( 0xb0 + y );                                  //set page address    
    uint8_t col_addr = FONT_SIZE * x + 2;  // Add 2-pixel offset for SH1106
    command_write( 0x00 + ( col_addr & 0x0f ) );               //set low col address
    command_write( 0x10 + ( ( col_addr >> 4 ) & 0x0f ) );      //set high col address
  }
  // Modified drawBar function for SH1106
  void drawBar( int16_t x, int16_t y, int16_t value ){
    int i;
    command_write( 0xb0 + y );                           //set page address
    uint8_t col_addr = FONT_SIZE * x + 2;  // Add 2-pixel offset for SH1106
    command_write( 0x00 + ( col_addr & 0x0f ) );        //set low col address
    command_write( 0x10 + ( ( col_addr >> 4 ) & 0x0f) );//set high col address
    for(i=0;i<128;i++) {
      if( i % 2 == 0 )   data_write( 0 );
      else {
        if( i <= value ) data_write( 0x7e );
        else             data_write( 0 );
      }
    }
  }  
  //---------------------------------------------------
  // 한글 루틴
  void putchEng( int16_t x, int16_t y, char ch, boolean normal_inverse ) {
    int16_t i, j;
    uint8_t value;    
    gotoXY( x, y );   
    Wire.beginTransmission( OLED_address ); // begin transmitting
    Wire.write( 0x40 );                     //data mode
    for(i=0;i<8;i++)  {
      value = pgm_read_byte( &E_font[ ch ][ i ] );
      if( normal_inverse )   Wire.write( value );
      else                   Wire.write( ~value );   
    }
    Wire.endTransmission();                 // stop transmitting
    //
    gotoXY( x, y + 1 );
    Wire.beginTransmission( OLED_address ); // begin transmitting
    Wire.write( 0x40 ); 
    for(i=0;i<8;i++)  {
      value = pgm_read_byte( &E_font[ ch ][ i + 8 ] );
      if( normal_inverse )   Wire.write( value );
      else                   Wire.write( ~value );   
    }
    Wire.endTransmission();                 // stop transmitting
    
  }
  void putchKor( int16_t x, int16_t y, uint8_t *korean, boolean normal_inverse ) {        /* display a 16x16 Dot Korean */    
    //https://blog.naver.com/kiatwins/220903792139
    byte cho1[22] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 3, 3, 1, 2, 4, 4, 4, 2, 1, 3, 0 };
    byte cho2[22] = { 0, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 6, 6, 7, 7, 7, 6, 6, 7, 5 };
    byte jong[22] = { 0, 0, 2, 0, 2, 1, 2, 1, 2, 3, 0, 2, 1, 3, 3, 1, 2, 1, 3, 3, 1, 1 }; 
    byte first=0, mid=0, last=0;
    byte firstType=0, midType=0, lastType=0;
    uint8_t i, j;
    uint16_t unicode,  pF_temp;;
    uint8_t buf[ 32 ], value;
    // https://hubbleconstant.tistory.com/6
    // UTF8을 UNICODE로
    unicode  = korean[ 0 ] & B00001111; 
    unicode <<= 6;
    unicode |= korean[ 1 ] & B00111111; 
    unicode <<= 6;
    unicode |= korean[ 2 ] & B00111111;
    // UNICODE에서 초성 중성 종성 분리  
    // 초성(20) : 없음ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ
    // 중성(22) : 없음ㅏㅐㅑㅒㅓㅔㅕㅖㅗㅘㅙㅚㅛㅜㅝㅞㅟㅠㅡㅢㅣ
    // 종성(28) : 없음ㄱㄲㄳㄴㄵㄶㄷㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅄㅅㅆㅇㅈㅊㅋㅌㅍㅎ
    //              가각갂갃간갅갆갇갈갉갊갋갌갍갎갏감갑값갓갔강갖갗갘강갚갛
    
    unicode -= 0xAC00;    // 0xAC00='가' ~  0xD7A3='힣' 11,172글자
    last = unicode % 28;  // 종성
    unicode /= 28;
    first = unicode / 21 + 1;  // 초성
    mid   = unicode % 21 + 1;  // 중성  
    //  
    if( last == 0 ){  //받침 없는 경우
      firstType = cho1[mid];
      if(first == 1 || first == 24) midType = 0;
      else midType = 1;
    }
    else{       //받침 있는 경우
      firstType = cho2[mid];
      if(first == 1 || first == 24) midType = 2;
      else midType = 3;
      lastType = jong[ mid ];
    }
    // 초성을 복사
    //초성(0~159)
    pF_temp = firstType * 20 + first;
    for(i=0;i<32;i++)     buf[ i ] = pgm_read_byte( &K_font[ pF_temp ][ i ] );
    //
    // 중성을 ORing (160~247)
    pF_temp = 160 + midType * 22 + mid;       
    for(i=0;i<32;i++)     buf[ i ] |= pgm_read_byte( &K_font[ pF_temp ][ i ] );
    //
    // 종성이 있으면 종성을 ORing
    if( last )   { 
      pF_temp = 248 + lastType * 28 + last;      
      for(i=0;i<32;i++)   buf[ i ] |= pgm_read_byte( &K_font[ pF_temp ][ i ] );
    } 
    //        
    gotoXY( x, y );  
    Wire.beginTransmission( OLED_address ); // begin transmitting
    Wire.write( 0x40 );   
    for(i=0;i<16;i++) {   
      if( normal_inverse )   Wire.write(  buf[ i ] );
      else                   Wire.write(  ~buf[ i ] );   
    }
    Wire.endTransmission();
    //
    gotoXY( x, y + 1 ); 
    Wire.beginTransmission( OLED_address ); // begin transmitting
    Wire.write( 0x40 );    
    for(i=0;i<16;i++) {
      if( normal_inverse )   Wire.write(   buf[ i + 16 ] );
      else                   Wire.write(  ~buf[ i + 16 ] );   
    }
    Wire.endTransmission();
  }
  void puts( int16_t x, int16_t y, unsigned char *str, boolean normal_inverse ) { //display a string 
    int8_t i;     
    uint8_t utf8[ 4 ];
    for(i=0; str[ i ] != NULL;)  { 
      if( str[ i ] < 0x80 ) {
        putchEng( x, y, str[ i++ ], normal_inverse ); // display English character
        x ++;
      }
      else { 
        utf8[ 0 ] = str[ i++ ];
        utf8[ 1 ] = str[ i++ ];
        utf8[ 2 ] = str[ i++ ];
        utf8[ 3 ] = NULL;
        putchKor( x, y, utf8, normal_inverse );               // display Korean character
        x += 2;
      }
    }
  }
  void drawBitmap32( uint8_t x, uint8_t y, int8_t num, boolean normal_or_inverse ) {
    uint8_t i, j, value;
    for(i=0;i<4;i++) {
      gotoXY( x, y++ );
      for(j=3;j<30;j++) {
        switch( num ) {
          case -1 : value = 0;  // blank
            break;
          case 0 :  value = pgm_read_byte_near( Seg0 + i * 32  + j  );
            break;
          case 1 :  value = pgm_read_byte_near( Seg1 + i * 32  + j  );
            break;
          case 2 :  value = pgm_read_byte_near( Seg2 + i * 32  + j  );
            break;
          case 3 :  value = pgm_read_byte_near( Seg3 + i * 32  + j  );
            break;
          case 4 :  value = pgm_read_byte_near( Seg4 + i * 32  + j  );
            break;
          case 5 :  value = pgm_read_byte_near( Seg5 + i * 32  + j  );
            break;
          case 6 :  value = pgm_read_byte_near( Seg6 + i * 32  + j  );
            break;
          case 7 :  value = pgm_read_byte_near( Seg7 + i * 32  + j  );
            break;
          case 8 :  value = pgm_read_byte_near( Seg8 + i * 32  + j  );
            break;
          case 9 :  value = pgm_read_byte_near( Seg9 + i * 32  + j  );
            break;
          case 10 :  value = pgm_read_byte_near( Seg10 + i * 32  + j  );  // o o
            break;
        }
        if( normal_or_inverse )   data_write( value );
        else                      data_write( ~value );
      }
    }
  }
  private:
  // TwoWire wire 멤버 제거 - 전역 Wire 객체 사용 (AVR/ESP32 호환)
};